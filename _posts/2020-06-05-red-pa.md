---
layout: default_post
title : 记一次秒杀抢红包的千层套路
category: 业务开发
---


前言：老千层套路了。

#### 导航
1. 场景描述
2. 第一层
3. 第二层
4. 第三层
5. 第三层
6. 第五层
7. 第千层
8. 总结


<br>
# 1. 场景描述

一个活动，n 个人抢红包，十分钟一轮，共 5 轮，

每轮一个红包，最多 50 个人能抢到，红包最多有 10s 有效期。

抢完要展示领取列表。

剩余金额必须可靠，因为最后一轮是所有剩余金额之和。

假设每一轮红包点发送时，都是预先设置入库，从 n 个人中确定好可以抢到的 50 人记录（状态未领取，点了才算领取）。

<br>
# 2. 第一层

直接用 mysql, 开撸

```
- redis 过期时间做 10s 有效期控制。

- begin 事务

- select 红包总金额 from table where id = 红包id for update
- select ...判断用户的领取状态，金额 （不在或者已领取直接 rollback 返回）
- 扣除红包金额 
- 设置该用户为已领取状态
- 钱包金额增加
- 流水记录增加

- commit 事务
- 返回金额，告诉用户领了多少

```

可以看到，对一个红包主键 id 进行 for update，其他竞争者都会等。领取完后设置状态，保障不重复领取。这样就不会有多领和超扣。


<br>
# 3. 第二层

上面那样肯定不行的，n 个人就有 n 个对库请求。优化肯定是用 redis 缓存。

```

- 计算可以领取的 50 人后入库，顺便入缓存。
- 缓存查到是有资格领取的 50 人才往下走，没资格的直接返回。
- 。。。其他按照上面的 mysql 操作

```
redis 过滤了一层，最大并发数就是有资格的人，最多50，看起来还不错。

但是如果多场活动，或者一个有资格的人使用特殊手段发起多次请求，还是对库有压力。


<br>
# 4. 第三层

```

- 计算可以领取的 50 人后入库，顺便入缓存。
- 做频控，每个人 10s 只能发起一次请求。
- 代码层面做互斥锁串行，比如 go 的 sync.Mutex (如果运行在 k8s，m 个 pod 就是 m 个锁)
- 。。。其他按照上面的 mysql 操作

```

因为串行化，并发就是同一时间 m 个请求会打到库。好像还不错。

但是，很多活动的时候，不同活动的红包领取，互相排队影响，可能会影响速度。

<br>
# 5. 第四层

异步大法好（虽然会带来新的复杂度）

```
同步部分：
- 返回缓存中的红包金额，很快。
- redis 缓存记录下已领取的用户和金额。

异步部分：
- 红包发出那一刻，设置一个任务, 入 mq 的延时队列（延时 11 秒）
- 使用 uuid ＋ redis 的 setex 去重，保证不重复消费

- 事务开始
- 根据 redis 领取金额，一次性扣除红包已经领取的金额 （mysql）
- 根据 redis 领取名单，一次性设置这些用户的红包为已经领取状态 (mysql)
- 事务结束

- 循环
- 事务开始
- 更新钱包
- 更新单个用户的流水
- 事务结束
- 循环 end

```

扣总金额 和 设置用户已领取状态在一个事务处理，优先处理。

钱包和流水表，每个用户单独的事务，哪怕中途有一个用户插入异常，数据也比较容易修复。(通过对比已领取状态表 和 流水表)

简单来说，就是接口同步先返回用户红包领取了多少。

异步任务中，优先扣除本轮所有已领取的红包金额。

至于用户钱包金额和流水，没那么迫切，慢慢给，没给到也能修复。

<br>
# 6. 第五层

其实，就这样还存在风险，比如 mq 生产者，消费者异常。导致数据没消费处理。

用户钱包金额没加还好，可以补。但是红包剩余金额没及时扣除，会影响最后的分配。

虽然说 mq 保证高可用就行，但也不排除可能性。毕竟会带来超扣风险，超扣的底线一定要守住。

解决方案，发红包前加一个 redis 锁（或者说 flag），最终完全消费完才解锁。

发送下轮红包前先检查这个锁（一轮红包间隔十分钟消费正常肯定解了），如果消费异常，也就是锁还没解开，发出告警信息，紧急修复。

毕竟这种情况下就是 mq 的可用性出问题。不仅仅是代码开发的问题了。

<br >
# 7. 第千层

我们来思考一下：

```
- 你以为就万事大吉了吗。
- 万一 用来加锁的 redis 挂了呢？ 
- 用 redis 集群吗？
- 万一集群也挂了呢？
- 万一宇宙爆炸 0 变成 1 了呢？
- emmmm....

- +1 层
- +1 层
- +n 层
- 套娃中。。。 

你以为我在第五层？ 其实我在大气层。

```

认真的说， mq 挂了 + redis 挂了 + redis 集群挂了。
这种就和中彩票差不多了。再说这些都挂了，可能你整个系统都不可用了，先把运维砍了吧。

<br>
# 8. 总结

思路就是

- 金额，不能超领，不能超扣
- 尽可能减少 mysql 压力
- 尽量提升响应速度
- 异步处理必须有容错和补偿机制
- 尽量不影响原来业务流程的设计





