---
layout: default_post
title : 直接插入排序【下：代码优化和分析】
category: 算法学习
---



前言：前面已经用代码实现了直接插入排序 [直接插入排序【中：代码实现】]({{site.data.host_url}}/2018/03/17/eight-algorithm-02)，现在看有哪些可以改进和对算法进行一些分析。

#### 导航
1. 代码优化
2. 时间复杂度
3. 空间复杂度
4. 算法稳定性
5. 适用场景
6. 总结


<br>
# 1. 代码优化

其实很简单，就是找不到的时候直接 break 即可，这样就避免了继续无畏的比较

```
    public static void sort(Comparable[] a) {
            int N = a.length;  
            for(int i = 1; i <= N-1; i++){  
                for(int j = i; j > 0; j--) { 
                    if(SortUtil.less(a[j], a[j-1])) { 
                        SortUtil.exch(a, j, j-1);
                    }else {
                        break; // 不用交换的时候记得停住！！
                    }
                }
                System.out.print("当i为"+i+"-->");
                SortUtil.show(a);
            }
    }
```

另外，其实算法里有一个很有用的角色叫做哨兵，可以用来简化很多边界问题的判断，（比如链表会用到哨兵作为头结点），有了哨兵我们可以写成下面那样，减少一些无谓的判断。不过这样会增加理解成本：

```
    public static void sortWithSentry(Comparable[] a) {
        int N = a.length;  
        int i, j;	
        for(i = 2; i < N; i++){  // 
            a[0] = a[i];
            for(j = i - 1; SortUtil.more(a[j], a[0]); j--) { 
                a[j+1]=a[j];
            }
            a[j+1]=a[0];

            System.out.print("当i为"+i+"-->");
            SortUtil.show(a);
        }
    }
```


<br>
# 2. 时间复杂度

最好情况下，数组本身已经是有序的，第二层循环基本不需要，每次插入只需要判断一次，n 次就是 n 次判断，所以复杂度是 O(n)

但是在最坏情况下，数组完全逆序，插入第 2 个元素时，需要比较 1 次，插入第 3 个元素时，要比较 2 次，……，以此类推，插入第 n 个元素时，要比较 n - 1 次。因此，最坏情况下的比较次数是 1 + 2 + 3 + ... + (n - 1)，等差数列求和，结果为 n^2 / 2，舍去常量 1/2, 所以最坏情况下的复杂度为 O(n^2)


<br>
# 3. 空间复杂度
按照上面的写法，即使两个数字相同，但是本来在后面的数字，排序时遇到大于和等于自己的时候就停了，并不会往前走，相同元素的先后顺序依旧不变，所以这是个稳定的算法


<br>
# 5. 适用场景
只适用于排序规模比较小，或者本身数组已经接近有序的时候使用

<br>
# 6. 总结
实际上很多类库都已经把各种各样的算法实现了，
但是知道一个算法大概怎么写，用的时候也更加有依据。
另外，知道时间复杂度，拿到一份数据，才能从规模和本身的有序性去思考和选择算法。
知道空间复杂度，结合程序的运行环境，我们才能决定是否用空间换时间。
知道稳定性，才不至于因为相同数据位置变动，导致业务逻辑漏洞。


