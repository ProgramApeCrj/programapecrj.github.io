I" <p>前言：epoll 这个概念最早了解的时候是在 nginx，然后一搜基本都是什么多路复用，五种 io 模型之类的，看了之后就只知道很吊的样子但是并没有看懂。。。后面学了一些基础后发现稍微能理解，可能离最终理解还有点距离，但是这里把理解的思路整理一下。</p>

<h4 id="导航">导航</h4>
<ol>
  <li>什么是阻塞</li>
  <li>cpu 和 网卡</li>
  <li>socket</li>
  <li>缓冲区</li>
  <li>fd 文件描述符</li>
  <li>用户态和内核态</li>
  <li>socket 的执行过程</li>
  <li>select 的执行过程</li>
  <li>epoll 的执行过程</li>
  <li>epoll 高效的本质</li>
  <li>epoll 的两种触发模式</li>
  <li>select 和 epoll 的对比</li>
  <li>参考</li>
</ol>

<p><br /></p>
<h1 id="1-什么是阻塞">1. 什么是阻塞</h1>

<p>事实上，很长一段时间我都被阻塞的概念给卡住了。别人总是说，阻塞不占用 cpu，这我知道。但是下面灵魂拷问总是搜不到答案：</p>
<ul>
  <li>为什么不占 cpu 呢？</li>
  <li>本质是什么呢？</li>
  <li>while(1) 循环为什么又会占用 cpu 呢？</li>
</ul>

<p>其实操作系统原理已经告诉我们这一点。</p>

<p>首先，我们要知道操作系统运行程序的时候，就单核系统来说，同一时间仅有一个程序在运行。操作系统只是无时无刻地在切换运行中的程序。而如何切换，是通过状态 + 队列去调度的：</p>

<ul>
  <li>执行（Running）状态</li>
</ul>

<p>当进程已获得 cpu，其程序正在 cpu 上执行，此时的进程状态称为执行状态。</p>

<ul>
  <li>就绪(Ready)状态 （就绪队列）</li>
</ul>

<p>当进程已分配到除 cpu 之外的所有必要的资源，只要获得 cpu 便可立即执行，这时的进程状态称为就绪状态，处于就绪队列中。一旦获得cpu ，就会被运行。</p>

<ul>
  <li>阻塞(Blocked)状态 （等待队列）</li>
</ul>

<p>正在执行的进程，由于在等待某个事件的发生(比如网络 io)，而无法执行时，便放弃 cpu 而处于阻塞状态，进入等待队列。</p>

<p>所以，从操作系统的层面上看，阻塞状态就是操作系统将进程放入等待队列，如果等待的事件一直不到达，那么就会一直处于等待队列，这时候程序基本不占用 cpu。</p>

<p>while(1) 循环的程序，由于大多数时间会处于执行状态，所以会一直占用 cpu。</p>

<p><br /></p>
<h1 id="2-cpu-和网卡">2. cpu 和网卡</h1>

<p>cpu 一直在运行程序，怎么知道网卡来数据了？</p>

<p>这就要搬出计组原理了：硬件中断。</p>

<p>硬件中断其实就是某个程序运行到一半，操作系统收到硬件的中断信号，强行让其停止（保留现场），以此让出 cpu，然后执行某个规定好的操作（程序）。</p>

<p>以网卡的硬件中断为例，有数据到达网卡时，网卡向 cpu 发出一个中断信号，操作系统得知有新数据到来，停止当前其他程序的运行，再通过已经约定好的网卡中断程序去处理数据。</p>

<p><br /></p>
<h1 id="3-socket">3. socket</h1>

<p>简单理解就是封装了一些细节，让应用程序和底层网卡打交道的时候可以更加简单。</p>

<p>指定了对方的 ip 和端口后，socket 就可以用 write/send 函数发送数据，使用 read/recv接收数据。对编程的人隐藏了具体细节。</p>

<p><br /></p>
<h1 id="4-缓冲区">4. 缓冲区</h1>

<p>事实上，每一层都有对应的缓冲区。</p>

<ul>
  <li>
    <p>网卡缓冲区
数据达到时，网卡通过 DMA 把网络包放在收包队列。发发生硬件中断，执行驱动中的中断程序。中断程序会拷贝数据到 sk_buff 缓冲区，然后再通过软中断，通知内核。</p>
  </li>
  <li>
    <p>内核缓冲区</p>
  </li>
</ul>

<p>内核解析 sk_buff 缓冲区，</p>

<p>每个 socket 被创建后，都会在内核中分配两个缓冲区，输入缓冲区和输出缓冲区。</p>

<p>然后执行驱动的中断程序。网卡中的数据写入输入缓冲区，等待用户读取。发送数据时候，程序只是将数据写入输出缓冲区，然后返回（所以返回不代表已经发送到对端）。</p>

<ul>
  <li>用户缓冲区</li>
</ul>

<p>用户程序自己创建的缓冲区（比如搞一个字节数组先存着），从内核中读取，放入该缓冲区，便于接下来的处理。</p>

<p>举个例子，redis 规定遇到 “\r\n” 的时候算一个完整的命令或结果，那就需要读取数据，放到一个字节数组，直到遇到 “\r\n”，才开始解析命令。</p>

<p><br /></p>
<h1 id="4-fd-文件描述符">4. fd 文件描述符</h1>

<p>Linux 万物皆文件。你对其他东西的操作，文件、目录、还是网络设备，其实都被抽象为是在操作文件。</p>

<p>既然万物皆文件，那我一个程序操作 n 个文件，肯定要管理起来这些文件，而且每个文件都应该有对应的标识才对，于是文件描述符就诞生了，可以将文件描述符当做这些已打开文件的标识，通过标识，程序可以对文件进行操作。</p>

<p><br /></p>
<h1 id="5-用户态和内核态">5. 用户态和内核态</h1>
<p>为了避免程序操作到其他程序的内存，或者一些关键内存。操作系统将内存分为用户内存 和 内核内存。</p>

<p>程序处于用户态只能操作自己分配的内存，不能随意操作内核内存。</p>

<p>系统调用，中断程序执行时，程序会进入内核态，执行完相应的内核程序后才会回到用户态。</p>

<p><br /></p>
<h1 id="6-socket-的执行过程">6. socket 的执行过程</h1>

<p>伪代码如下：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//创建socket
int s = socket(AF_INET, SOCK_STREAM, 0); 

//程序绑定该 socket
bind(s, ...)

//设置监听的端口
listen(s, ...)

//接受客户端连接
int c = accept(s, ...)

//接收客户端数据
recv(c, ...);

//将数据打印出来
printf(...)

</code></pre></div></div>

<p>画出来的图大概是这样</p>

<p>过程解释:</p>
<ul>
  <li>计算机收到了对端传送的数据</li>
  <li>数据经由网卡传送到内存</li>
  <li>网卡通过中断信号通知 cpu 有数据到达，cpu 执行中断程序</li>
  <li>中断程序将网络数据写入到对应 socket 的接收缓冲区里面，再将进程A 从等待队列扔到就绪队列，让其处于就绪状态</li>
  <li>进程获取到 cpu 后，由就绪状态变成运行状态，通过 socket，就可以到相应的缓冲区获取数据</li>
  <li>数据全部读完之后，进程又回到阻塞状态，直到下一次网卡数据到达时被唤醒</li>
</ul>

<h1 id="select-的执行过程">select 的执行过程</h1>

<p>web 服务器，需要同时维护多个客户端的连接，或者说多个 socket, 肯定不能写成上面那样。为了维护多个连接，select 诞生了。</p>

<p>以 go 代码为例子</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p>画图分析：
…</p>

<p>简单总结就是，数据到达的时候，网卡中断程序执行，根据 socket 的等待队列定位到程序 A 要处理，于是唤醒 A，让 A 进入就绪状态，获得 cpu 后运行。A 一旦开始执行，就会调用 select。</p>

<p>select 被调用时，并不知道自己维护的 socket 里哪些来数据。 想知道是哪个 socket 有数据到达，要遍历所有 socket，判断其 fd_set，然后读取数据。</p>

<p>selcet 效率不高的原因如下：</p>

<p>这里的 socket 只有 3个，但是当 socket 有成千上万个的时候，遍历的开销就变的巨大。并且进程和操作系统的最大句柄数有限。</p>

<p>另外，句柄会有多次拷贝：</p>

<p>首先，创建 socket 句柄后，需要从向内核态（内存）拷贝</p>

<p>然后，要进行内容读取，select会将之前传递给内核的文件句柄再次从内核传到用户态</p>

<p>最后，fd_set 被修改后，想要再次复位，句柄需要再次从用户态向内核态进行拷贝</p>

<p><br /></p>
<h1 id="7-总结">7. 总结</h1>
<p>一点小总结</p>

<ul>
  <li></li>
</ul>

:ET