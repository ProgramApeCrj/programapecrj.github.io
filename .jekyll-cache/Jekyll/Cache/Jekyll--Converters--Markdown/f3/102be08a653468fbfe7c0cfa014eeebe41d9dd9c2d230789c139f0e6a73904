I"~<p>前言：老千层套路了。</p>

<h4 id="导航">导航</h4>
<ol>
  <li>场景描述</li>
  <li>第一层</li>
  <li>第二层</li>
  <li>第三层</li>
  <li>第三层</li>
  <li>第五层</li>
  <li>总结</li>
</ol>

<p><br /></p>
<h1 id="1-场景描述">1. 场景描述</h1>

<p>一个活动，n 个人抢红包，十分钟一轮，共 5 轮，</p>

<p>每轮一个红包，最多 50 个人能抢到，红包最多有 10s 有效期。</p>

<p>抢完要展示领取列表。</p>

<p>剩余金额必须可靠，因为最后一轮是所有剩余金额之和。</p>

<p>假设红包点发送时，都是预先设置入库，从 n 个人中确定好可以抢到的 50 人记录（状态未领取，点了才算领取）。</p>

<p><br /></p>
<h1 id="2-第一层">2. 第一层</h1>

<p>直接用 mysql, 开撸</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>。。。省略利用 redis 过期时间做时间控制的部分。。。

- begin 事务

- select 红包总金额 from table where id = 红包id for update
- select ...判断用户的领取状态，金额 （不在或者已领取直接 rollback 返回）
- 扣除红包金额 
- 设置该用户为已领取状态
- 钱包金额增加
- 流水记录增加

- commit 事务
</code></pre></div></div>

<p>可以看到，对一个红包主键 id 进行 for update，其他竞争者都会等。领取完后设置状态，保障不重复领取。这样就不会有多领和超扣。</p>

<p><br /></p>
<h1 id="3-第二层">3. 第二层</h1>

<p>优化肯定是用 redis 缓存拉。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 计算可以领取的 50 人后入库，顺便入缓存。
- 缓存查到是有资格领取的 50 人才往下走，没资格的直接返回。
- 其他按照上面的 mysql 操作

</code></pre></div></div>
<p>redis 过滤了一层，最大并发数就是有资格的人，看起来还不错。</p>

<p>但是如果多场活动，或者一个有资格的人使用特殊手段发起多次请求，还是对库有压力。</p>

<p><br /></p>
<h1 id="4-第三层">4. 第三层</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 计算可以领取的 50 人后入库，顺便入缓存。
- 做频控，每个人 10s 只能发起一次请求。
- 代码层面做互斥锁串行 (如果是 k8s，m 个 pod 就是 m 个锁)
- 其他按照上面的 mysql 操作

</code></pre></div></div>

<p>因为串行化，并发就是同一时间 m 个请求会打到库。好像还不错。</p>

<p>但是，安全是安全了，速度慢，特别是很多活动，全部互相排队影响。</p>

<p><br /></p>
<h1 id="5-第四层">5. 第四层</h1>

<p>异步大法好（虽然会带来新的复杂度）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>同步部分：
- 返回缓存中的红包金额，很快。
- redis 缓存记录下已领取的用户和金额

异步部分：
- 延时最大红包领取时间＋1s，比如 11s, 入 mq 队列
- 使用 uuid ＋ redis 的 setex去重，保证不重复消费
- 事务开始
- 扣总额
- 根据个红包为已领取
- 事务结束

循环
事务开始
更新流水＋钱包
事务结束



</code></pre></div></div>

<p>你会发现，最终你并不能说我究竟用了哪几种设计模式，但是演进的过程却是参考了设计模式的想法。不同语言对于设计模式的代码诠释也不一定一样。</p>

<p><br /></p>
<h1 id="7-总结">7. 总结</h1>
<p>一点小总结</p>

<ul>
  <li>写代码从最简单入手，暴力的写法满足的话，可以不用过度优化。</li>
  <li>进行迭代的时候，发现有问题了，可以开始尝试封装，不然你不知道能演变成什么样子。</li>
  <li>代码是演进的，不是一蹴而就，别人的框架亦是如此。</li>
  <li>不要拘泥于语言或者设计模式，不同语言可能写出来不是很一样，但是核心思想也都是设计模式说的开放封闭原则。用大白话说，就是增加新的功能，不需要有看别人的代码，不需要改别人的代码，不需要有过多的心智负担。</li>
</ul>

:ET