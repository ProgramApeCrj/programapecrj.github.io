I"<p>前言：前面已经用代码实现了直接插入排序，现在看有哪些可以改进和对算法进行一些分析。</p>

<h4 id="导航">导航</h4>
<ol>
  <li>代码优化</li>
  <li>时间复杂度</li>
  <li>空间复杂度</li>
  <li>算法稳定性</li>
  <li>适用场景</li>
  <li>总结</li>
</ol>

<p><br /></p>
<h1 id="1-代码优化">1. 代码优化</h1>

<p>其实很简单，就是找不到的时候直接 break 即可，这样就避免了继续无畏的比较</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void sort(Comparable[] a) {
        int N = a.length;  
        for(int i = 1; i &lt;= N-1; i++){  
            for(int j = i; j &gt; 0; j--) { 
                if(SortUtil.less(a[j], a[j-1])) { 
                    SortUtil.exch(a, j, j-1);
                }else {
                    break; // 不用交换的时候记得停住！！
                }
            }
            System.out.print("当i为"+i+"--&gt;");
            SortUtil.show(a);
        }
}

</code></pre></div></div>

<p><br /></p>
<h1 id="2-对称加密-和-非对称加密">2. 对称加密 和 非对称加密</h1>

:ET