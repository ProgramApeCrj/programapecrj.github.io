I"/<p>前言：虽然之前看过一些设计模式的书或者专栏，但也只是依样画瓢，没有体验过为什么要有设计模式的思维。经历过一次工作中对代码的优化后，终于明白了一丢丢。下面把思路再复现一下。</p>

<h4 id="导航">导航</h4>
<ol>
  <li>场景描述</li>
  <li>暴力写法</li>
  <li>依样画瓢</li>
  <li>进行优化</li>
  <li>考虑演进</li>
  <li>再一次封装</li>
  <li>总结</li>
</ol>

<p><br /></p>
<h1 id="1-场景描述">1. 场景描述</h1>

<p>在开发中，很多时候要收集小程序用户的一些业务上报，比如足迹，点赞，观看时长等等。通过上报后，借助 kafka 来进行消费。</p>

<p>现在的场景是这样的，业务分为多种，会和前端约定相应的key。比如</p>
<ul>
  <li>10001 代表足迹</li>
  <li>10002 代表点赞</li>
  <li>10003 代表支付</li>
  <li>。。。</li>
</ul>

<p>要求对不同 key 都编写对应的一个处理过程，或入库，或做累加等等。。规则也各不相同。</p>

<h1 id="2-暴力写法">2. 暴力写法</h1>

<p>其实上面的场景很简单，上来不用思考就可以写了：</p>

<p>写三个办法分别处理不同的 key</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun handle10001(msg Msg) {
   // todo 处理逻辑
}

fun handle10002 (msg Msg) {
   // todo 处理逻辑
}

fun handle10003 (msg Msg) {
   // todo 处理逻辑
}

</code></pre></div></div>
<p>然后消费数据的时候直接调用</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func cus(msg Msg){
   if msg.key == "10001"{
      handle10001(msg)
   }else if msg.key == "10002"{
      handle10002(msg)
   }else if msg.key == "10003"{
      handle10003(msg)
   }
}


</code></pre></div></div>

<p><br /></p>
<h1 id="3-依样画瓢">3. 依样画瓢</h1>

<p>暴力写法其实也可以，也挑不出什么毛病。但是这段时间我可是在看设计模式，怎么也得写个工厂办法之类的把，于是变成如下这样：</p>

<p>定义了处理数据的接口</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type msgHandle interface{
   handle(msg Msg)
}

</code></pre></div></div>

<p>每个需要处理 key 的程序都需要实现该接口(鸭子类型)</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type handle10001 struct {

}

func(h handle10001) handle(msg Msg){
   // todo 处理逻辑
}

type handle10002 struct {

}

func(h handle10002) handle(msg Msg){
   // todo 处理逻辑
}

type handle10003 struct {

}

func(h handle10003) handle(msg Msg){
   // todo 处理逻辑
}

</code></pre></div></div>

<p>因此处理的逻辑变成了</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func cus(msg Msg){
   var msgh msgHandle

   if msg.key == "10001"{
      msgh = handle10001{}
   }else if msg.key == "10002"{
      msgh = handle10002{}
   }else if msg.key == "10003"{
      msgh = handle10003{}
   }

   msgh.handle(msg)
}

</code></pre></div></div>

<p><br /></p>
<h1 id="4-进行优化">4. 进行优化</h1>

<p>上面就是学了设计模式的人的通病，有了锤子，啥都是钉子。那样写虽然看起来好像不错，实际上和之前的并没有太大区别。</p>

<p>不过，工厂模式其实可以通过 map 去优化，优化后如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mmp := make(map[string]msgHandle)
mmp["10001"] = handle10001{}
mmp["10002"] = handle10002{}
mmp["10003"] = handle10003{}

</code></pre></div></div>

<p>调用程序就显得更加简单直观，增加其他的 key 只需要修改 map, 然后编写对应的结构体</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func cus(msg Msg){
   msgh, _ := mmp[msg.key]
   msgh.handle(msg)
}
</code></pre></div></div>

<p><br /></p>
<h1 id="5-考虑演进">5. 考虑演进</h1>

<p>就这样我写了处理 10001 的代码。这时候，同时小峰对我说，他也要处理10001, 而且和我的处理方式不同。我就跟他说，那你封装个办法，写在我下面把，代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type handle10001 struct {

}

func(h handle10001) handle(msg Msg){
   // todo 我的处理逻辑

   // 小峰的
   xiaofengHandle(msg Msgs)
}


func xiaofengHandle(msg Msg){

}

</code></pre></div></div>

<p>相信这段代码很容易看出弊端，现在只有小峰，以后还有小志，小源，他们都要处理 10001，而且处理的方式完全不一样，怎么办？</p>

<p>一旦人多起来，办法就变得臃肿，而且我每次要改自己的代码，都要看有没有动到别人的代码，增加了心智负担。另外，如果我 panic 了，下面的代码都执行不到了，我怕是要被人群殴。</p>

<p>这时候我突然想到，可以用发布订阅的方式，我们在代码层面，不同的 key 作为一个事件，别人都来订阅，消费该 key 的时候通知所有的订阅者。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type handle10001 struct {
   observerList []observer
}

func(h handle10001) addObserver(ob observer) {
   h.observerList = append(h.observerList, ob)
}

func(h handle10001) handle(msg Msg){
   for _,o := range h.observerList {
      o.update(msg)
   }
}

type observer interface{
   update(msg Msg)
}

type my10001observer struct {
}

func(my my10001observer) update(msg Msg)  {
   // 我对100001的处理
}

type xiaoFeng10001observer struct {
}

func(xiaofeng xiaoFeng10001observer) update(msg Msg)  {
   // 小峰对100001的处理
}

</code></pre></div></div>

<p>执行如下</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 这里的初始化可以放在 init 里
obs := handle10001{[]observer{}} 
obs.addObserver(my10001observer{}) // 我的
obs.addObserver(xiaoFeng10001observer{}) // 小峰的
mmp["10001"] = obs

// 办法
func cus(msg Msg){
   obs, _ := mmp[msg.key]
   obs.handle(msg)// 通知要处理的人
}

</code></pre></div></div>

<p>handle 办法这样写还可以避免两人的 pannic 互相影响</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func handleWithCoverPanic(obs observer, msg Msg) {
   defer func() {
      if err := recover(); err != nil {
         // 处理 panic
      }
   }()
   obs.update(msg)
}

func(h handle10001) handle(msg Msg){
   for _,o := range h.observerList {
      handleWithCoverPanic(o,msg)
   }
}

</code></pre></div></div>

<p><br /></p>
<h1 id="6-再一次封装">6. 再一次封装</h1>
<p>其实上面的代码已经符合开放封闭原则了。但是好像创建了过多的结构体。实际上，go 语言可以能直接把函数当参数的，为啥我要这么麻烦创建结构体呢？不要被别的语言所束缚：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div>

<p>你会发现，最终你并不能说我用了哪种设计模式，但是演进的过程却是参考了设计模式的想法。不同语言对于设计模式的代码诠释也不一定一样。</p>

<p><br /></p>
<h1 id="7-总结">7. 总结</h1>
<p>一点小总结</p>

<ul>
  <li>写代码从最简单入手，暴力一点满足的话，就不用过度优化</li>
  <li>一旦发现可以封装，尝试封装，不然只会 bv</li>
  <li>代码是演进的，不是一蹴而就</li>
</ul>

<p>接下来有空要整理一下所有的设计模式</p>
:ET