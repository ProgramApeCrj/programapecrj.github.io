I"<p>前言：老千层套路了。</p>

<h4 id="导航">导航</h4>
<ol>
  <li>场景描述</li>
  <li>第一层</li>
  <li>第二层</li>
  <li>第三层</li>
  <li>第三层</li>
  <li>第五层</li>
  <li>总结</li>
</ol>

<p><br /></p>
<h1 id="1-场景描述">1. 场景描述</h1>

<p>一个活动，n 个人抢红包，十分钟一轮，共 5 轮，</p>

<p>每轮一个红包，最多 50 个人能抢到，红包最多有 10s 有效期。</p>

<p>抢完要展示领取列表。</p>

<p>剩余金额必须可靠，因为最后一轮是所有剩余金额之和。</p>

<p>假设红包点发送时，都是预先设置入库，从 n 个人中确定好可以抢到的 50 人记录（状态未领取，点了才算领取）。</p>

<p><br /></p>
<h1 id="2-第一层">2. 第一层</h1>

<p>直接用 mysql, 开撸</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- redis 过期时间做 10s 有效期控制。

- begin 事务

- select 红包总金额 from table where id = 红包id for update
- select ...判断用户的领取状态，金额 （不在或者已领取直接 rollback 返回）
- 扣除红包金额 
- 设置该用户为已领取状态
- 钱包金额增加
- 流水记录增加

- commit 事务
</code></pre></div></div>

<p>可以看到，对一个红包主键 id 进行 for update，其他竞争者都会等。领取完后设置状态，保障不重复领取。这样就不会有多领和超扣。</p>

<p><br /></p>
<h1 id="3-第二层">3. 第二层</h1>

<p>优化肯定是用 redis 缓存拉。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 计算可以领取的 50 人后入库，顺便入缓存。
- 缓存查到是有资格领取的 50 人才往下走，没资格的直接返回。
- 。。。其他按照上面的 mysql 操作

</code></pre></div></div>
<p>redis 过滤了一层，最大并发数就是有资格的人，看起来还不错。</p>

<p>但是如果多场活动，或者一个有资格的人使用特殊手段发起多次请求，还是对库有压力。</p>

<p><br /></p>
<h1 id="4-第三层">4. 第三层</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
- 计算可以领取的 50 人后入库，顺便入缓存。
- 做频控，每个人 10s 只能发起一次请求。
- 代码层面做互斥锁串行 (如果是 k8s，m 个 pod 就是 m 个锁)
- 。。。其他按照上面的 mysql 操作

</code></pre></div></div>

<p>因为串行化，并发就是同一时间 m 个请求会打到库。好像还不错。</p>

<p>但是，安全是安全了，速度慢，特别是很多活动，全部互相排队影响。</p>

<p><br /></p>
<h1 id="5-第四层">5. 第四层</h1>

<p>异步大法好（虽然会带来新的复杂度）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>同步部分：
- 返回缓存中的红包金额，很快。
- redis 缓存记录下已领取的用户和金额。

异步部分：
- 延时 11s, 入 mq 队列
- 使用 uuid ＋ redis 的 setex 去重，保证不重复消费
- 事务开始
- 根据 redis 领取金额，一次性扣除红包已经领取的金额
- 根据 redis 领取名单，一次性设置这些用户的红包为已经领取状态
- 事务结束

- 循环
- 事务开始
- 更新单个用户的流水＋钱包
- 事务结束
- 循环 end

</code></pre></div></div>

<p>扣总金额 和 设置用户已领取状态在一个事务处理。</p>

<p>钱包和流水表，每个用户单独的事务，哪怕中途有一个用户插入异常，数据也比较容易修复。(通过对比已领取状态表 和 流水表)</p>

<p>可以理解为就是红包先领，告诉你成功，领取的列表也能先给到展示。</p>

<p>至于钱包金额和流水，没那么迫切，慢慢给，没给到也能修复。</p>

<p><br /></p>
<h1 id="6-第五层">6. 第五层</h1>

<p>其实，就这样还存在风险，比如 mq 生产者，消费者异常。导致数据没消费处理。</p>

<p>用户钱包金额没加还好，可以补。但是红包剩余金额没及时扣除，会影响最后的分配。</p>

<p>虽然说 mq 保证高可用就行，但也不排除可能性。毕竟会带来超扣风险，超扣的底线一定要守住。</p>

<p>解决方案，发红包前加一个 redis 锁（或者说 flag），最终完全消费完才解锁，发送下轮红包前先检查这个锁，如果还没解开，发出告警，紧急修复。</p>

<p>毕竟这种情况下就是系统的可用性出问题。不仅仅是开发的问题了。</p>

<p><br /></p>
<h1 id="7-总结">7. 总结</h1>
<p>一点小总结</p>

<ul>
  <li>写代码从最简单入手，暴力的写法满足的话，可以不用过度优化。</li>
  <li>进行迭代的时候，发现有问题了，可以开始尝试封装，不然你不知道能演变成什么样子。</li>
  <li>代码是演进的，不是一蹴而就，别人的框架亦是如此。</li>
  <li>不要拘泥于语言或者设计模式，不同语言可能写出来不是很一样，但是核心思想也都是设计模式说的开放封闭原则。用大白话说，就是增加新的功能，不需要有看别人的代码，不需要改别人的代码，不需要有过多的心智负担。</li>
</ul>

:ET